1.Java线程创建后，调用start()方法进入就绪状态，调用run方法进入运行状态，同一Thread对象即同一线程，在线程的整个生命过程中，只会调用一次start()，线程调用stop()后进入终止状态。



2.Java Set中对象具有以下哪些特点



3.接口中的数据成员为final static， 接口中的数据成员为public abstract，接口是无法被实例化的，所以没有构造方法，若实现接口的是抽象方法，则没有必要都实现接口中的方法。




  9.

class S

{         

char p[10]; 

public:  

​         S & operator=(S &a) {

​		}

};  



C++运算符重载



10. C++   cout  cerr(标准错误流(非缓冲))  clog(标准错误流(缓冲))；都可以输出。

    cout的输出可以重定向到一个文件中，cerr必须输出到显示器上；

    cerr不经过缓冲区，而clog的信息存在缓冲区中，缓冲区满或是遇上endl才输出。cerr是保证在程序调用的栈用完了时也能输出。





13.

某公司要开发一个即时聊天软件，用户可以与多位好友同时聊天，在私聊时将产生多个聊天窗口，为提高窗口创建效率，要求根据第一个窗口快速创建其他窗口。在该需求情况下，应采用（    D  ）设计最为合适

*A*`享元模式`

*B*`单例模式`

*C*`组合模式`

*D*`原型模式`



享元模式（Flyweight）：String常量池，数据库连接池，缓冲池等等都是享元模式的应用。主要用于减少创建对象的数量，以减少内存占用和提高性能。

单例模式：只有一个实例。

组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，用户对单个对象和组合对象的使用具有一致性。

原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。（影分身）

原型模式的本质是：克隆生成对象。



观察者模式：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖它的对象都会得到通知并自动更新。

观察者模式最重要的作用就是 解耦！将观察者与被观察者解耦，使得他们之间的依赖性更小。（秒杀按钮由灰变红）

(1)**周期性任务**。比如linux中的周期性任务命令crontab命令，win7下的定时关机命令shutdown -s -t 1200(1200s后关机)。这些命令当预期系统时间到后，就可以通知相应的观察者激活相应的命令。

(2)**重新加载配置文件**。现在做大型系统基本都会有配置文件，例如在SSH项目中每次修改配置文件后，都需要重新启动服务器才能使得新的配置文件生效(当然SSH中貌似已经提供了参数设置，当配置文件修改时，可以自动重新加载)。



迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。（通过特定的接口访问容器的数据，而不需要了解容器的内部结构）



各模式代码（面试）：



16.

封锁机制：封锁机制是控制并发的主要手段，封锁有三个步骤：1.请求加锁，对要使用的数据提出加锁请求2.获得锁，系统允许事务获得数据的控制权 3.释放锁

基本的封锁类型有两种：排它锁（Exclusive locks，X锁） 共享锁（Share locks，S锁）



排他锁又称写锁，只允许有数据控制权的事务进行读和写操作，直到释放锁为止其他事务都不能对该数据进行读取和修改，也不能加其他类型的锁。



共享锁，又称读锁，若事务T对数据加上S锁，则事务可以读该数据，但不能修改，其他事务也只能对该数据加S锁而不能加X锁，直到事务T释放该数据上的S锁。



*A*`能够避免不可重复读取问题`

*B*`能够避免不读“脏”数据`

*C*`不能避免不可重复读取和不读“脏”数据的问题`

*D*`可避免更新丢失的问题`



一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束释放。不能避免不可重复读取和不读“脏”数据的问题，可避免更新丢失问题，并能够保证事务的可恢复性。

二级封锁协议：事务T对要修改数据必须先加X锁，直到事务结束才释放X锁；对要读取的数据先加S锁，读取结束后释放S锁。不但能够防止丢失修改，还能够避免读“脏”数据，但是由于二级封锁协议对数据读完后即释放S锁，所以不能避免”不可重复读“错误。

三级封锁协议：事务T在读取数据之前加S锁，在修改数据前加X锁，直到事务结束后才释放所有锁。不但防止了丢失修改和不读”脏数据“，还能够防止不可重复读取问题



17.

在数据库ER图中，



实体用矩形框表示；

联系（关系）用菱形框表示；

属性用椭圆形框表示



18.

单CPU系统中通常采用两级处理器调度，以下相关描述正确的是（ AD     ）

*A*`作业调度是从慢速存储设备中的后备队列中挑选作业加载到主存中。`

*B*`作业调度是从慢速存储设备中的就绪队列中挑选作业加载到主存中。`

*C*`进程调度是从主存中中的后备队列中挑选进程占用处理器运行。`

*D*`进程调度是从主存中中的就绪队列中挑选进程占用处理器运行。`



作业调度：高级调度又称作业调度或宏观调度。其功能是按一定的调度算法把外存上处于后备作业队列的作业调入内存，为它们分配所需的资源并创建进程，然后将新创建的进程插入到系统的进程就绪队列中。

功能：1.选择作业   2.分配资源  3.创建进程  4.作业控制  5.回收资源



交换调度：又称中级调度。功能是在内存使用紧张的情况下。将内存中暂时无法运行的进程挂起，即由内存调至外存（换出），使外存上具备运行条件的就绪进程能够及时进入内存运行。

进程调度：又称低级调度或微观调度。其主要功能是按照一定的调度算法将CPU分派给进程就绪队列中的某个进程。



（未完）

https://www.cnblogs.com/Diligent-Memory/p/10806686.html





19.

系统采用页式存储管理方案，若页号块号对应关系存于内存中，且内存的访问时间为1μs，则当快表命中率为50%和85%时，有效的存取时间分别为（B      ）

*A*`0.85μs和0.5μs`

*B*`1.5μs和1.15μs`

*C*`1.15μs和1.5μs`

*D*`0.5μs和0.85μs`



页式存储管理方案：





20.

有关CSMA/CD协议特点描述正确的是（      AC）

*A*`可抢占性的`

*B*`不可抢占性的`

*C*`半双工介质访问控制协议`

*D*`全双工介质访问控制协议`



若信道正忙，如果坚持监听，发送的站一旦停止就立即抢占信道，但是可能几个站同时监听，同时抢占信道；

半双工：发送方发送，接送方监听，无法发送，无法成为全双工



CSMA/CD协议（Carrier Sense Multiple Access/collision detection，带有冲突检测的载波侦听多路存取）：



21.

系统工程师管理应用层协议时，首先要确定使用面向连接传输服务还是面向无连接服务，下列使用无连接传输的应用层协议有（     BC ）

*A*`ssh`

*B*`snmp`

*C*`dhcp`

*D*`telnet`



ssh：

snmp：简单的网络管理协议

dhcp:动态主机设置协议

telnet：







24.

已知主串S=“ababcabcacbab”，模式T=“abcac”。利用KMP算法进行匹配时，需要进行几次才可以匹配成功（   A   ）

*A*`3`

*B*`4`

*C*`5`

*D*`6`



next数组：0 0 0 1 0
第一次 :
a b a b c a b c a c b a b
a b c a c
匹配个数2-字符'b'(匹配的最后一个字符的)的next值0=2 即后移两位
第二次：
a b a b c a b c a c b a b
a b c a c
匹配个数4-字符'a'的next值1=3 即后移三位
第三次：
a b a b c a b c a c b a b
a b c a c
匹配成功！





25.

已知存在8阶对称矩阵，采用压缩存储方式按行序为主序存储，每个元素占一个地址空间。若a22为元素的存储地址为1，每个元素占一个地址空间，则a74的地址为（   B   ）

*A*`11`

*B*`23`

*C*`32`

*D*`33`



压缩存储方式：





26.

下列序列规模较大时，选择哪种排序算法效率最高（      ）

*A*`直接选择排序`

*B*`直接插入排序`

*C*`冒泡排序`

*D*`希尔排序`



各大排序特点:





27.

使用二分法在序列1,4,6,7,15,33,39,50,64,78,75,81,89,96中查找元素81时,需要经过（      ）次比较

*A*`4`

*B*`3`

*C*`2`

*D*`12`



28.

对含有31个元素的序列采用直接选择排序算法排序，在最坏情况下需要进行多少次移动才能完成排序（   D   ）

*A*`31`

*B*`30`

*C*`60`

*D*`90`



直接选择排序：





30.

使用直接插入排序算法对序列18,23,19,9,23,15进行排序，第三趟排序后的结果为（      ）

*A*`9,18,15,23,19,23`

*B*`18,23,19,9,23,15`

*C*`18,19,23,9,23,15`

*D*`9,18,19,23,23,15`



18,23,19,9,23,15
第一遍： 18 19 9 23 23 15
第二遍： 18 9 19 23 23 15
第三遍： 9 18 19 23 23 15