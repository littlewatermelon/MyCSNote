#### 散列表（Hash表）

由散列函数将关键值对应相应地址；最佳情况下查找为O（1）

解决散列冲突：开放定址法、链接法

散列表的查找效率取决于：1. 散列函数 2.处理冲突的方法 3.装填因子

装填因子 = 记录数/散列表长度





#### KMP算法

字符串处理

求next数组，本质上是求最长前缀；

求next的方法：

next[1] = 0 ,next[2] = 1;

求3及其之后：(j)

k = next[j-1]，

若S[k] == S[j-1]（S为字符串），则next[j] = k + 1

若S[k] != s[j-1] 且 k = 0，则next[j] = 1

若S[k] != s[j-1] 且 k != 0，则k = next[k]并重复上述过程

例：abaabcac

next[1] = 0 , next[2] = 1;



next[3] : k = next[2] = 1; s[1] != s[2] --->  k = next[k] = 0; s[0] != s[2],next[3]=1



next[4]: k = next[3] = 1, s[1] == s[3] ---> next[4] = 1+1 =2;



next[5]: k = next[4] = 2, s[2] != s[4]  ---> k= next[2] = 1; s[1] == s[4], next[5] = k+1 = 2;



next[6]: k = 2; s[2] == s[5], next[6] = k+1 = 3;



next[7]: k= 3; s[3]  != s[7-1], k = next[3] = 1; s[1] != s[6], k = s[1] = 0, 则next[7]=1;



next[8]: k = 1; s[1] == s[8-1] , next[8] = k+1 = 2；





#### 红黑树

性质：1.每个节点非红即黑

​			2.根节点为黑

​			3.红节点的两个孩子必须是黑

​			4.从根节点到任意叶子结点的黑节点个数相同

因为最短路径全是黑节点，最长路径黑红交替，故最长路径不超过最短的2倍



相较于平衡二叉树，红黑树是一种弱平衡二叉树，相同节点下它的高度高于平衡二叉树，故插入和删除时旋转更少，整体性能略优于AVL，故对于删除、插入更多的情况下使用红黑树。





B树、B+树、LSM、