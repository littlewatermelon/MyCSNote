#### 1.满二叉树

​	高为h，拥有
$$
2^h - 1
$$
个结点的二叉树。

若对满二叉树自上而下，自左向右编号，则编号为i的结点，若有双亲，其双亲为i/2（向下取整） ， 若有左孩子，为2i，若有右孩子，为2i+1



#### 2.完全二叉树

​	高度为h，结点为n的二叉树，每个结点都与自上而上从左到右依次排序编号的满二叉树的结点一一对应。

特点：

​	①. i<= n/2（向下取整）为分支结点，否则为叶子结点

​	②. 若某结点为叶子节点或只有左孩子结点，大于其编号的均为叶子结点

​	③. 如果有度为1的结点，只能有一个，且只有左孩子

​	④. 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（n/2）只有左节点，其余分支结点均有左孩子和右孩子。

​	

#### 3.二叉排序树

​	左子树上所有结点的关键字均小于根结点的关键字，右子树上的所有结点均大于根结点的关键字。左子树和右子树又格式一棵二叉排序树。



#### 4.平衡二叉树

​	树上任一结点的左子树和右子树的深度之差不超过1。



### 二叉树性质

1.非空二叉树上叶子结点数等于度为2的结点数+1。

2.非空二叉树第K层最多有2^(k-1)个结点

3.高度为H的二叉树最多有2^H -1 个结点

4.具有N个（N>0）结点的二叉树的高度为,
$$
log_2(N+1)向上取整，或log_2N向下取整+1
$$




### 二叉树的遍历

N为 根节点，L、R分别为左子树，右子树

1.先序遍历（NLR）

2.中序遍历（LNR）

3.后序遍历（LRN）

每个结点都访问一次且仅访问一次，故时间复杂度为O(n)，在递归遍历中，递归工作栈的深度恰好为树的深度，故最坏情况下空间复杂度为O(n)。



非递归算法：用栈

中序遍历：

​	

```
void InOrder(BiTree T){
	InitStack(s);	//初始化栈
	BiTree p = T;	//p为遍历指针
	while(p || !s.empty() ){
		if(p){
			push(s,p);
			p = p->lchild;
		}else{
			pop(s,p);
			visit(p);
			p = p->rchild; //访问右子树，会存在没有左子树但是有右子树的情况
		}
	}
	
}
```



先序遍历：

```
void PreOrder(BiTree T){
	InitStack(S);
	Bitree p = T;
	while( p || !isEmpty(s) ){
		while( p ){		//访问跟结点，存入根节点，再进入左子树
			visit(p);
			Push(S,p);
			p = p->lchild;
		}
		
		if(!isEmpty(s)){
			Pop(S,p);
			p = p->rchild;//进入右子树
		}
		
	}
}
```



后序遍历：

```
void PostOrder(BiTree T){
	InitStack(S);
	BiTree p = T;
	BiTree r = null;	//标志指针，用于记录前一结点
	while( p || !isEmpty(S) ){
		if( p ){
			Push(p);
			p = p->lchild;
		}else{
			p = S.top();	//取得栈顶
			if( p->rchild != null && r->rchild != r){
				p = p->rchild;
				Push(S,p);
				p = p->lchild;
			}else{
				visit(p);
				Pop(s,r);	//记录已访问的右孩子结点
				p = null;
				
			}
		}//else end
		
	}
}
```



层次遍历：用队列

```
void LevelOrder(BiTree T){
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);	//根节点入队
	while(!isEmpty(Q)){
		DeQueue(Q,p);
		visit(p);
		if(p->lchild != null){
			EnQueue(Q,p->lchild);
		}
		if( p->rchild != null ){
			Enqueue(Q,p->rchild); 
		}
	}
	
	
}
```





## 树与二叉树的应用

#### 1.二叉排序树（Binary Sort Tree）BST

又称二叉查找树，是一颗空树，或具有以下特征：

（1）若左子树非空，则左子树上所有结点关键字值均小于根节点的关键字值

（2）若右子树非空，则右子树所有结点的关键字值均小于根节点的关键字值

（3）左右子树本身也是二叉排序树



##### 二叉排序树的查找

